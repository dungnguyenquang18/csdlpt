\documentclass[14pt]{extarticle}

% --- HỖ TRỢ TIẾNG VIỆT ---
\usepackage[utf8]{inputenc}      % đầu vào Unicode
\usepackage[T5]{fontenc}         % font T5 cho tiếng Việt
\usepackage[vietnamese]{babel}   % tiếng Việt

% --- CĂN LỀ & ĐỊNH DẠNG ---
\usepackage[left=2.5cm,right=2cm,top=2cm,bottom=2cm]{geometry} 
\setlength{\parindent}{0pt}

% --- VẼ HÌNH, ĐỒ HỌA ---
\usepackage{graphicx} 
\usepackage{tikz} 
\usepackage{float}


% --- KÝ HIỆU & MATH ---
\usepackage{array}
\usepackage{mathabx}
\usepackage{amsmath}
\usepackage{amsmath}
\usepackage{makecell}
\usepackage{amsthm}
\newtheorem{definition}{Định nghĩa}
\usepackage{changepage} % Cho phép điều chỉnh lề

% --- TRANG TRÍ ---
\usepackage{wallpaper}
\usepackage{dashrule}
\usepackage[normalem]{ulem}
\usepackage{xcolor}

% --- DANH SÁCH, LIÊN KẾT ---
\usepackage{enumitem} 
\usepackage{hyperref}

% --- MÃ NGUỒN ---
\usepackage{listings}
\lstset{
  backgroundcolor=\color{gray!10},
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=true,
  captionpos=b,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  columns=fullflexible,
  keepspaces=true
}

% --- KHÁC ---
\usepackage{caption}
\usepackage{scrextend}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}


% --- FONT CỠ ---
\usepackage{titlesec}
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}

% Nếu cần chỉnh cỡ chữ chung:
\usepackage{anyfontsize}
\fontsize{16pt}{15.6pt}\selectfont
\linespread{1.2}





% Cài đặt listings
\lstset{
    language=[x86masm]Assembler,
    basicstyle=\ttfamily\normalsize, % hoặc \fontsize{14pt}{16pt}\selectfont
    backgroundcolor=\color{gray!10},
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    breaklines=true,
    captionpos=b,
    columns=fullflexible,
    keepspaces=true
}

% Font chữ và tiêu đề
\usepackage{titlesec}
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\linespread{1.2}

\begin{document}
	\newpage
	\begin{titlepage}
		\begin{tikzpicture}[remember picture,overlay,inner sep=0,outer sep=0]
			 \draw[blue!70!black,line width=4pt] 
			 ([xshift=1cm,yshift=1.5cm]current page.south west) coordinate (A)
			 -- ([xshift=-1cm,yshift=1.5cm]current page.south east) coordinate (B)
			 -- ([xshift=-1cm,yshift=-1.5cm]current page.north east) coordinate (C)
			 -- ([xshift=1cm,yshift=-1.5cm]current page.north west) coordinate (D)
			 -- cycle;
			 
			 % Viền gấp khúc trong
			 \draw ([yshift=0.5cm,xshift=-0.5cm]C)-- ([yshift=0.5cm,xshift=0.5cm]D)--
			 ([yshift=-0.5cm,xshift=0.5cm]D) --([yshift=-0.5cm,xshift=-0.5cm]D)
			 --([yshift=0.5cm,xshift=-0.5cm]A)--([yshift=0.5cm,xshift=0.5cm]A)
			 --([yshift=-0.5cm,xshift=0.5cm]A)-- ([yshift=-0.5cm,xshift=-0.5cm]B)
			 --([yshift=0.5cm,xshift=-0.5cm]B)--([yshift=0.5cm,xshift=0.5cm]B)
			 --([yshift=-0.5cm,xshift=0.5cm]C)--([yshift=-0.5cm,xshift=-0.5cm]C)
			 --([yshift=0.5cm,xshift=-0.5cm]C);
			 
			 \draw ([yshift=-0.3cm,xshift=0.3cm]C)-- ([yshift=-0.3cm,xshift=-0.3cm]D)--
			 ([yshift=0.3cm,xshift=-0.3cm]D) --([yshift=0.3cm,xshift=0.3cm]D)
			 --([yshift=-0.3cm,xshift=0.3cm]A)--([yshift=-0.3cm,xshift=-0.3cm]A)
			 --([yshift=0.3cm,xshift=-0.3cm]A)-- ([yshift=0.3cm,xshift=0.3cm]B)
			 --([yshift=-0.3cm,xshift=0.3cm]B)--([yshift=-0.3cm,xshift=-0.3cm]B)
			 --([yshift=0.3cm,xshift=-0.3cm]C)--([yshift=0.3cm,xshift=0.3cm]C)
			 --([yshift=-0.3cm,xshift=0.3cm]C);
			
		\end{tikzpicture}
		\begin{center}
			\vspace{2pt}
			
			\textbf{HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG}
			
			\vspace{7pt}
			\textbf{KHOA CÔNG NGHỆ THÔNG TIN 1}
			
			\vspace{4pt}
			\hdashrule[0.5ex]{6cm}{1pt}{2mm 0.5mm}
		\end{center}
		
		\vspace{10pt}
		\begin{center}
			\includegraphics[scale=0.7]{ptit.png}
			
			\vspace{10pt}
			\fontsize{18pt}{17pt}\selectfont 
			\textbf{BÀI CÁO KẾT THÚC HỌC PHẦN} 
			
			\vspace{7pt}
			\textbf{MÔN CƠ SỞ DỮ LIỆU PHÂN TÁN}
		\end{center}
		

		
		\hspace{5cm}

		\begin{adjustwidth}{0.5cm}{0cm}
    \begin{tabbing}
        \fontsize{16pt}{20pt}\selectfont
        \hspace{6cm} \= \hspace{4cm} \= \kill
        \textbf{Giảng viên hướng dẫn:} \> \textbf{TS. KIM NGỌC BÁCH} \>\\ [6pt]
        \textbf{Nhóm học phần:} \> \textbf{09} \>\\ [6pt]
        \textbf{Nhóm bài tập lớn:} \> \textbf{05} \>\\ [6pt]
        \textbf{Thành viên nhóm:} \> \textbf{NGUYỄN QUANG DŨNG B22DCCN133} \>\\ [6pt]
                            \> \textbf{NGUYỄN TUẤN NAM B22DCCN561} \>\\ [6pt]
                            \> \textbf{LÊ ĐĂNG NINH B22DCCN572} \>\\ [6pt]
    \end{tabbing}
\end{adjustwidth}

		
		
		\vspace{14pt}
        \hspace{10cm}
		\begin{center}
			\textbf{Hà Nội, 2025}
		\end{center}
	\end{titlepage}
	

\clearpage

% Mục lục
\tableofcontents

\clearpage

% Danh mục hình vẽ

\renewcommand{\listfigurename}{Danh mục hình ảnh}
\listoffigures
\addcontentsline{toc}{section}{Danh mục hình ảnh}



\renewcommand{\listtablename}{Danh mục bảng biểu}
\listoftables
\addcontentsline{toc}{section}{Danh mục bảng biểu}
\newpage
\section{Phân chia công việc}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{8cm}|}
        \hline
        \textbf{Thành viên} & \textbf{Công việc thực hiện} \\
        \hline
        Nguyễn Quang Dũng & 
        - Thiết kế và cài đặt hàm  \\
        & - Viết tài liệu hướng dẫn sử dụng chương trình \\
        & - Feedback báo cáo\\
        \hline
        Nguyễn Tuấn Nam & 
         - Kiểm thử chương trình\\&
         - Feedback báo cáo \\
        \hline
        Lê Đăng Ninh & 
        - Kiểm thử chương trình\\&
        - Tổng hợp và viết báo cáo\\
        \hline
    \end{tabular}
    \caption{Bảng phân chia công việc giữa các thành viên}
\end{table}
\newpage
\section{Phân tích yêu cầu đề bài}
\subsection{Bối cảnh hiện tại}
Trong thời đại dữ liệu phát triển mạnh mẽ hiện nay, việc xử lý và quản lý khối lượng dữ liệu lớn đang đặt ra nhiều thách thức cho các hệ thống cơ sở dữ liệu. \\

Khi dữ liệu gia tăng với tốc độ chóng mặt, các phương pháp truyền thống lưu trữ toàn bộ dữ liệu trong một bảng đơn lẻ dễ dẫn đến tình trạng suy giảm hiệu suất, hạn chế khả năng mở rộng và ảnh hưởng đến tính sẵn sàng của hệ thống.\\

Phân mảnh dữ liệu (Data Partitioning) là một giải pháp quan trọng trong thiết kế cơ sở dữ liệu phân tán, cho phép chia nhỏ một bảng dữ liệu lớn thành nhiều phân đoạn nhỏ hơn, gọi là các phân mảnh (partitions hoặc fragments). \\

-> Mỗi phân mảnh này có thể được lưu trữ và xử lý riêng biệt, giúp nâng cao hiệu quả truy vấn, rút ngắn thời gian phản hồi và hỗ trợ hệ thống mở rộng linh hoạt hơn.

\subsection{Nhiệm vụ yêu cầu}
Mô phỏng các phương pháp phân mảnh dữ liệu trên một hệ quản trị cơ sở dữ liệu quan hệ mã nguồn mở (ví dụ: PostgreSQL hoặc MySQL).\\
Mỗi nhóm sinh viên phải tạo một tập các hàm Python để tải dữ liệu đầu vào vào một bảng quan hệ, phân mảnh bảng này bằng các phương pháp phân mảnh ngang khác nhau, và chèn các bộ dữ liệu mới vào đúng phân mảnh.
\subsection{Mục tiêu bài tập}
\begin{itemize}
    \item Mô phỏng quá trình phân mảnh ngang dữ liệu trên một bảng quan hệ sử dụng:
    \begin{itemize}
        \item Dữ liệu thực tế: Tập tin \texttt{ratings.dat} của MovieLens 10M
        \item Cơ sở dữ liệu: PostgreSQL
        \item Ngôn ngữ lập trình: Python
    \end{itemize}
    \item Áp dụng hai phương pháp phân mảnh:
    \begin{itemize}
        \item \textbf{Range Partitioning:} Là phương pháp phân mảnh dữ liệu bằng cách chia bảng thành các phân mảnh dựa trên các khoảng giá trị của một thuộc tính nào đó (ví dụ: giá trị của Rating, UserID, hoặc MovieID).\\
        Mỗi phân mảnh chứa các bản ghi có giá trị thuộc tính nằm trong một khoảng xác định trước. Phương pháp này phù hợp khi dữ liệu có phân bố theo thứ tự rõ ràng và các truy vấn thường tập trung vào một khoảng cụ thể.
        \item \textbf{Round-Robin Partitioning:} Là phương pháp phân mảnh dữ liệu bằng cách phân phối các bản ghi lần lượt và đều đặn vào các phân mảnh theo thứ tự vòng tròn. Bản ghi đầu tiên vào phân mảnh 1, bản ghi thứ hai vào phân mảnh 2, và cứ thế tiếp tục cho đến phân mảnh cuối cùng rồi quay lại phân mảnh 1.\\
        Phương pháp này đảm bảo các phân mảnh có kích thước gần như bằng nhau, giúp cân bằng tải, nhưng không quan tâm đến giá trị của dữ liệu nên không tối ưu cho các truy vấn theo điều kiện.
    \end{itemize}
    \item Các thao tác yêu cầu:
    \begin{itemize}
        \item \textbf{Load dữ liệu vào một bảng gốc tên ratings:}
        \begin{itemize}
            \item Viết các hàm Python để đọc dữ liệu từ tệp \texttt{ratings.dat} theo đúng định dạng (UserID::MovieID::Rating::Timestamp).
            \item Chuyển dữ liệu thành định dạng phù hợp (ví dụ: tách các trường bằng dấu ::) và tải vào một bảng quan hệ ban đầu có tên là \texttt{ratings} trong hệ quản trị cơ sở dữ liệu đã chọn (PostgreSQL hoặc MySQL).
            \item Đảm bảo bảng \texttt{ratings} có các cột tương ứng: UserID, MovieID, Rating, Timestamp, với kiểu dữ liệu phù hợp.
        \end{itemize}
        \item \textbf{Phân mảnh bảng này theo:}
        \begin{itemize}
            \item \textbf{Khoảng (Range):}
            \begin{itemize}
                \item Tạo các bảng phân mảnh riêng biệt (ví dụ: \texttt{ratings\_range\_part1}, \texttt{ratings\_range\_part2}, ...) dựa trên các khoảng giá trị của trường Rating hoặc trường khác.
                \item Viết hàm để duyệt qua dữ liệu trong bảng \texttt{ratings} và chèn từng bản ghi vào phân mảnh phù hợp theo khoảng giá trị đã định nghĩa.
            \end{itemize}
            \item \textbf{Vòng luân phiên (Round-Robin):}
            \begin{itemize}
                \item Tạo các bảng phân mảnh (ví dụ: \texttt{ratings\_rr\_part1}, \texttt{ratings\_rr\_part2}, ...) theo số lượng phân mảnh đã định trước.
                \item Viết hàm Python để phân phối các bản ghi từ bảng \texttt{ratings} vào các phân mảnh theo thứ tự tuần tự, xoay vòng đều đặn.
            \end{itemize}
        \end{itemize}
        \item \textbf{Chèn dữ liệu mới và tự động đưa vào đúng phân mảnh tương ứng:}
        \begin{itemize}
            \item Xây dựng các hàm hỗ trợ chèn bản ghi mới vào hệ thống.
            \item Đảm bảo khi một bản ghi mới được thêm vào, hệ thống sẽ tự động xác định và chuyển bản ghi đó vào phân mảnh phù hợp:
            \begin{itemize}
                \item Nếu phân mảnh theo Range: xác định khoảng giá trị tương ứng với bản ghi.
                \item Nếu phân mảnh theo Round-Robin: tiếp tục phân phối theo thứ tự lần lượt dựa trên chỉ số chèn trước đó.
            \end{itemize}
            \item Có thể sử dụng một bảng phụ hoặc biến hệ thống để theo dõi chỉ số phân phối hiện tại trong phương pháp Round-Robin.
        \end{itemize}
    \end{itemize}
\end{itemize}
% ...existing code...
\subsection{Công nghệ sử dụng}
\begin{itemize}
    \item \textbf{Hệ điều hành:} Ubuntu 22.04 / Windows 10
    \item \textbf{Ngôn ngữ lập trình:} Python 3.12.x\\
    Phiên bản Python 3.12.x đảm bảo tính tương thích với các thư viện hiện đại, cải thiện hiệu suất và hỗ trợ tốt hơn về quản lý bộ nhớ, giúp xây dựng các ứng dụng cơ sở dữ liệu phân tán hiệu quả và ổn định.
    \item \textbf{Hệ quản trị SQL:} PostgreSQL\\
    PostgreSQL được sử dụng làm hệ quản trị cơ sở dữ liệu chính nhờ vào tính năng mạnh mẽ, hỗ trợ đầy đủ các chuẩn SQL, khả năng mở rộng và tính bảo mật cao.\\
    PostgreSQL không chỉ hỗ trợ tốt việc lưu trữ và truy vấn dữ liệu phức tạp mà còn cung cấp các công cụ quản trị mạnh như replication (nhân bản), partitioning (phân mảnh), indexing nâng cao, rất phù hợp với các hệ thống cơ sở dữ liệu phân tán.
    \item \textbf{Thư viện Python:} psycopg2\\
    Đây là thư viện phổ biến nhất để kết nối Python với PostgreSQL. \texttt{psycopg2} cho phép thực hiện các thao tác như kết nối cơ sở dữ liệu, truy vấn, thêm, sửa, xóa dữ liệu một cách dễ dàng và hiệu quả.\\
    Trong quá trình triển khai, \texttt{psycopg2} được sử dụng để viết các đoạn mã thực hiện phân mảnh, đồng bộ hóa dữ liệu và kiểm tra tính toàn vẹn.
    \item \textbf{IDE:} VSCode / PyCharm\\
    VSCode nổi bật với giao diện nhẹ, khả năng mở rộng mạnh mẽ thông qua các plugin, hỗ trợ đa nền tảng và cộng đồng sử dụng rộng rãi.\\
    PyCharm là một IDE chuyên sâu dành cho Python, hỗ trợ tốt cho việc kiểm tra mã nguồn, gỡ lỗi (debug), và tích hợp công cụ quản lý cơ sở dữ liệu.
\end{itemize}


\clearpage
\section{Cơ sở lý thuyết}

\subsection{Phân mảnh}
\textbf{a. Định nghĩa}\\
Phân mảnh là quá trình chia một cơ sở dữ liệu thành các phần nhỏ hơn gọi là mảnh (fragments) để lưu trữ trên các vị trí phân tán khác nhau trong hệ cơ sở dữ liệu phân tán. Mỗi mảnh vẫn có thể được xử lý độc lập và đảm bảo rằng dữ liệu vẫn có thể truy xuất đầy đủ và chính xác khi cần thiết.

\textbf{b. Phân loại}
\begin{itemize}
    \item \textbf{Phân mảnh ngang:} Là dạng phân mảnh trong đó các dòng (bản ghi, tuples) của một bảng được chia thành nhiều tập con khác nhau, mỗi tập con là một mảnh.
    \begin{itemize}
        \item Mỗi mảnh ngang chứa một tập hợp con của các hàng trong bảng.
        \item Các mảnh này được xác định bằng điều kiện phân mảnh (ví dụ: WHERE region = 'HCM').
        \item Các mảnh phải không trùng lặp và hợp lại sẽ cho ra bảng ban đầu.
        \item \textbf{Các kiểu phân mảnh ngang:} Range Partition, Round Robin Partition, Hash Partition, List Partition.
        \item \textbf{Ví dụ:} Giả sử có bảng \texttt{Customers(id, name, region)}:
        \begin{itemize}
            \item Fragment 1 (F1): chứa các khách hàng ở miền Bắc\\
            \texttt{SELECT * FROM Customers WHERE region = 'North';}
            \item Fragment 2 (F2): chứa các khách hàng ở miền Nam\\
            \texttt{SELECT * FROM Customers WHERE region = 'South';}
            \item $\Rightarrow$ Tập hợp F1 $\cup$ F2 = bảng Customers ban đầu.
        \end{itemize}
    \end{itemize}
    \item \textbf{Phân mảnh dọc:} Là kỹ thuật chia một bảng thành các mảnh dựa trên các cột (thuộc tính). Mỗi mảnh sẽ chứa một tập con của các cột ban đầu (kèm theo khóa chính để đảm bảo khả năng ghép nối).
    \begin{itemize}
        \item Mỗi mảnh dọc có tập cột riêng biệt, nhưng phải bao gồm khóa chính để có thể kết hợp lại bảng gốc khi cần.
        \item Dữ liệu vẫn có thể tái tạo bằng JOIN theo khóa chính.
        \item \textbf{Ví dụ:} Bảng \texttt{Employee(id, name, address, salary)}:
        \begin{itemize}
            \item Fragment 1: \texttt{Employee\_F1(id, name, address)}
            \item Fragment 2: \texttt{Employee\_F2(id, salary)}
            \item $\Rightarrow$ Tái tạo lại bảng gốc bằng:\\
            \texttt{SELECT * FROM Employee\_F1 JOIN Employee\_F2 USING(id);}
        \end{itemize}
    \end{itemize}
    \item \textbf{Phân mảnh hỗn hợp:} Kết hợp của phân mảnh ngang và dọc. Có thể phân mảnh ngang trước rồi phân mảnh dọc, hoặc ngược lại.
    \begin{itemize}
        \item \textbf{Ví dụ:} Bảng \texttt{Customer(id, name, region, phone, email)}
        \begin{itemize}
            \item Bước 1: Phân mảnh ngang theo region\\
            F1: Khách hàng miền Bắc\\
            F2: Khách hàng miền Nam
            \item Bước 2: Phân mảnh dọc F1 và F2\\
            F1\_1: (id, name, region)\\
            F1\_2: (id, phone, email)\\
            F2\_1: (id, name, region)\\
            F2\_2: (id, phone, email)
            \item $\Rightarrow$ Khôi phục bảng gốc:\\
            JOIN F1\_1 với F1\_2 $\rightarrow$ F1\\
            JOIN F2\_1 với F2\_2 $\rightarrow$ F2\\
            UNION F1 với F2 $\rightarrow$ Bảng Customer
        \end{itemize}
    \end{itemize}
\end{itemize}

\textbf{c. Tác dụng}
\begin{itemize}
    \item Tăng hiệu suất truy xuất dữ liệu tại các site cục bộ.
    \begin{itemize}
        \item Khi dữ liệu được phân mảnh và lưu trữ tại các site (địa điểm) khác nhau, mỗi site có thể lưu trữ các mảnh dữ liệu mà nó thường xuyên truy cập. 
        \item Điều này có nghĩa là các truy vấn do người dùng tại site đó thực hiện có thể được xử lý ngay tại chỗ mà không cần truy xuất dữ liệu từ site khác. 
    \end{itemize}
    \item Giảm lưu lượng truyền dữ liệu qua mạng.
    \begin{itemize}
        \item Khi áp dụng phân mảnh hiệu quả (đặc biệt là theo cách phân tích các mô hình truy cập), các mảnh dữ liệu được lưu tại nơi chúng thường xuyên được truy vấn.  
        \item Điều này giúp giảm đáng kể số lượng truy vấn và khối lượng dữ liệu phải truyền qua mạng, tiết kiệm băng thông và giảm chi phí vận hành mạng.
    \end{itemize}
    \item Cải thiện tính sẵn sàng và khả năng song song của hệ thống.
    \begin{itemize}
        \item Phân mảnh giúp tăng tính sẵn sàng của hệ thống vì các site có thể hoạt động độc lập ngay cả khi một hoặc vài site khác bị lỗi hoặc gián đoạn.
        \item Nhờ đó, hiệu năng tổng thể của hệ thống được cải thiện đáng kể, đặc biệt trong môi trường có nhiều người dùng truy cập đồng thời.
    \end{itemize}
\end{itemize}

\subsection{Range Partition}
\textbf{Định nghĩa:}\\
Là kỹ thuật phân mảnh ngang trong đó các bản ghi được chia thành các mảnh dựa trên giá trị của một thuộc tính nhất định nằm trong các khoảng xác định trước (thường là khóa hoặc cột có thứ tự, ví dụ ngày tháng, ID, số tiền,...).

\textbf{Đặc điểm:}
\begin{itemize}
    \item Dữ liệu được chia theo điều kiện phạm vi (range).
    \item Mỗi mảnh chứa các dòng có giá trị trong một khoảng nhất định.
    \item Các khoảng không được chồng lặp nhau.
\end{itemize}

% ...existing code...
\textbf{Ví dụ:}\\
Bảng \texttt{Orders(order\_id, customer\_id, total\_amount)} phân mảnh theo \texttt{total\_amount}:
\begin{itemize}
    \item Fragment 1 (F1): \texttt{total\_amount < 100}
    \item Fragment 2 (F2): \texttt{100 $\leq$ total\_amount < 500}
    \item Fragment 3 (F3): \texttt{total\_amount $\geq$ 500}
\end{itemize}
Khi truy vấn:\\
% ...existing code...
\texttt{SELECT * FROM Orders WHERE total\_amount >= 500;}\\
$\rightarrow$ Hệ thống chỉ cần truy vấn F3, giúp tiết kiệm thời gian và tài nguyên.

\subsection{Round Robin Partition}
\textbf{Định nghĩa:}\\
Là kỹ thuật phân mảnh ngang đơn giản, trong đó các bản ghi được phân phối đều đặn và tuần tự vào các mảnh theo vòng tròn, không phụ thuộc vào giá trị thuộc tính nào.

\textbf{Đặc điểm:}
\begin{itemize}
    \item Mỗi bản ghi tiếp theo sẽ được gán vào mảnh kế tiếp theo thứ tự vòng tròn.
    \item Đảm bảo các mảnh có kích thước gần như bằng nhau.
    \item Không tối ưu cho các truy vấn chọn lọc theo điều kiện.
\end{itemize}

\textbf{Ví dụ:}\\
Với bảng \texttt{Employee} và 3 mảnh dữ liệu:
\begin{itemize}
    \item Dòng 1 $\rightarrow$ Fragment 1
    \item Dòng 2 $\rightarrow$ Fragment 2
    \item Dòng 3 $\rightarrow$ Fragment 3
    \item Dòng 4 $\rightarrow$ Fragment 1
    \item Dòng 5 $\rightarrow$ Fragment 2
    \item ...
\end{itemize}

\textbf{Ưu điểm:}
\begin{itemize}
    \item Phân phối dữ liệu đồng đều, giúp cân bằng tải.
    \item Dễ triển khai, không cần phân tích dữ liệu.
\end{itemize}
\textbf{Nhược điểm:}
\begin{itemize}
    \item Không hỗ trợ truy vấn theo điều kiện hiệu quả, vì phải tìm kiếm trên tất cả các mảnh.
\end{itemize}

\subsection{So sánh Range Partition và Round Robin Partition}
\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|>{\centering\arraybackslash}p{3.5cm}|>{\centering\arraybackslash}p{5.2cm}|>{\centering\arraybackslash}p{5.2cm}|}
        \hline
        \textbf{Tiêu chí} & \textbf{Range Partition} & \textbf{Round Robin Partition} \\
        \hline
        Phân phối dữ liệu & Theo khoảng giá trị, có thể không đều & Đều, tuần tự từng dòng \\
        \hline
        Dễ bảo trì & Đơn giản & Đơn giản \\
        \hline
        Khả năng mở rộng & Dễ mở rộng & Dễ mở rộng \\
        \hline
        Thích hợp với loại dữ liệu & Có tính thứ tự hoặc theo vùng giá trị rõ ràng (thời gian, mã ID,...) & Không có mẫu truy vấn rõ ràng, cần phân phối đều \\
        \hline
        Hiệu suất INSERT & Nhanh – O(1) nếu có sẵn khóa phân mảnh, phải kiểm tra khoảng phù hợp & Rất nhanh – O(1), chỉ cần ghi lần lượt theo thứ tự vòng \\
        \hline
        Hiệu suất SELECT với điều kiện & Rất nhanh nếu có điều kiện trên partition key – partition elimination & Chậm – phải scan toàn bộ các partition \\
        \hline
    \end{tabular}
    \caption{So sánh Range Partition và Round Robin Partition}
\end{table}
\clearpage

\section{Phân tích và thiết kế giải pháp}
\subsection{Phân tích dữ liệu đầu vào}

Dữ liệu đầu vào sử dụng trong bài toán là tệp \texttt{ratings.dat} từ bộ dữ liệu MovieLens 10M. Mỗi dòng trong tệp có định dạng như sau:

\begin{center}
\texttt{UserID::MovieID::Rating::Timestamp}
\end{center}

\textbf{Ý nghĩa các trường:}
\begin{itemize}
    \item \textbf{UserID}: ID của người dùng (kiểu số nguyên).
    \item \textbf{MovieID}: ID của bộ phim (kiểu số nguyên).
    \item \textbf{Rating}: Điểm đánh giá của người dùng cho bộ phim, trên thang điểm 5 (có thể có giá trị lẻ như 3.5, 4.0, 5.0).
    \item \textbf{Timestamp}: Dấu thời gian, là số giây kể từ 0 giờ UTC ngày 1 tháng 1 năm 1970 (dạng Unix timestamp).
\end{itemize}

\textbf{Dữ liệu cần sử dụng:}  
Trong quá trình xử lý và phân mảnh, chỉ ba trường đầu tiên được sử dụng: \texttt{UserID}, \texttt{MovieID}, \texttt{Rating}. Trường \texttt{Timestamp} có thể bỏ qua vì không ảnh hưởng đến quá trình phân mảnh.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{data.png}
    \caption{file ratings.dat}

\end{figure}

Mỗi dòng thể hiện một đánh giá của người dùng đối với một bộ phim tại một thời điểm nhất định. Dữ liệu này sẽ được nạp vào bảng \texttt{ratings} trong cơ sở dữ liệu để thực hiện các thao tác phân mảnh tiếp theo.

\subsection{Phân tích và thiết kế các hàm chính}
\subsubsection{Hàm loadrating}

\textit{Phân tích:}  
Hàm này chịu trách nhiệm đọc dữ liệu từ file (dạng ratings.dat) và nạp vào bảng gốc \texttt{ratings} trong cơ sở dữ liệu. Dữ liệu đầu vào thường có định dạng: \texttt{UserID:MovieID:Rating:Timestamp}.

\textit{Đầu vào:}
\begin{itemize}
    \item \texttt{ratingstablename}: Tên bảng sẽ lưu dữ liệu (thường là \texttt{ratings}).
    \item \texttt{ratingsfilepath}: Đường dẫn tới file dữ liệu.
    \item \texttt{openconnection}: Kết nối tới cơ sở dữ liệu.
\end{itemize}

\textit{Đầu ra:}  
Không trả về giá trị, nhưng tạo bảng và nạp dữ liệu thành công vào CSDL.

\textit{Thiết kế:}
\begin{itemize}
    \item Nếu bảng đã tồn tại thì xóa đi để tránh trùng lặp.
    \item Tạo bảng mới với các trường: \texttt{userid}, \texttt{movieid}, \texttt{rating}.
    \item Đọc file, xử lý dữ liệu và nạp vào bảng bằng lệnh \texttt{COPY} hoặc \texttt{INSERT}.
    \item Đảm bảo dữ liệu đúng định dạng, loại bỏ các trường không cần thiết.
\end{itemize}

\subsubsection{Hàm rangepartition}

\textit{Phân tích:}  
Chia bảng \texttt{ratings} thành nhiều bảng con theo từng khoảng giá trị của trường \texttt{rating} (ví dụ: 0-1, 1-2,...).

\textit{Đầu vào:}
\begin{itemize}
    \item \texttt{ratingstablename}: Tên bảng gốc.
    \item \texttt{numberofpartitions}: Số lượng phân mảnh (partition).
    \item \texttt{openconnection}: Kết nối tới CSDL.
\end{itemize}

\textit{Đầu ra:}  
Tạo ra các bảng con \texttt{range\_part0}, \texttt{range\_part1}, ..., mỗi bảng chứa các dòng thuộc một khoảng rating nhất định.

\textit{Thiết kế:}
\begin{itemize}
    \item Tính toán khoảng giá trị cho mỗi partition.
    \item Tạo các bảng con tương ứng.
    \item Dùng truy vấn \texttt{INSERT INTO ... SELECT ... WHERE ...} để phân phối dữ liệu vào từng bảng con.
\end{itemize}


\subsubsection{Hàm roundrobinpartition}

\textit{Phân tích:}  
Chia bảng \texttt{ratings} thành nhiều bảng con theo phương pháp luân phiên từng dòng (dòng 1 vào bảng 0, dòng 2 vào bảng 1,...).

\textit{Đầu vào:}
\begin{itemize}
    \item \texttt{ratingstablename}: Tên bảng gốc.
    \item \texttt{numberofpartitions}: Số lượng phân mảnh.
    \item \texttt{openconnection}: Kết nối tới CSDL.
\end{itemize}

\textit{Đầu ra:}  
Tạo ra các bảng con \texttt{rrobin\_part0}, \texttt{rrobin\_part1}, ..., mỗi bảng chứa các dòng theo thứ tự luân phiên.

\textit{Thiết kế:}
\begin{itemize}
    \item Đánh số thứ tự các dòng trong bảng gốc.
    \item Chia đều các dòng vào các bảng con dựa trên chỉ số dòng và số partition.
    \item Đảm bảo mỗi bảng con nhận đúng các dòng theo quy tắc round-robin.
\end{itemize}

\subsubsection{Hàm rangeinsert}


\textit{Phân tích:}  
Chèn một bản ghi mới vào bảng gốc và vào đúng bảng con range partition phù hợp với giá trị rating.

\textit{Đầu vào:}
\begin{itemize}
    \item \texttt{ratingstablename}: Tên bảng gốc.
    \item \texttt{userid}, \texttt{itemid}, \texttt{rating}: Thông tin bản ghi mới.
    \item \texttt{openconnection}: Kết nối tới CSDL.
\end{itemize}

\textit{Đầu ra:}  
Bản ghi mới được thêm vào bảng gốc và đúng bảng con range partition.

\textit{Thiết kế:}
\begin{itemize}
    \item Chèn bản ghi vào bảng gốc.
    \item Xác định partition phù hợp dựa trên giá trị rating.
    \item Chèn bản ghi vào bảng con tương ứng.
\end{itemize}


\subsubsection{Hàm roundrobininsert}

\textit{Phân tích:}  
Chèn một bản ghi mới vào bảng gốc và vào bảng con round-robin tiếp theo.

\textit{Đầu vào:}
\begin{itemize}
    \item \texttt{ratingstablename}: Tên bảng gốc.
    \item \texttt{userid}, \texttt{itemid}, \texttt{rating}: Thông tin bản ghi mới.
    \item \texttt{openconnection}: Kết nối tới CSDL.
\end{itemize}

\textit{Đầu ra:}  
Bản ghi mới được thêm vào bảng gốc và đúng bảng con round-robin.

\textit{Thiết kế:}
\begin{itemize}
    \item Chèn bản ghi vào bảng gốc.
    \item Xác định bảng con round-robin tiếp theo dựa trên tổng số bản ghi đã có.
    \item Chèn bản ghi vào bảng con tương ứng.
\end{itemize}

\subsection{Thiết kế giải pháp cho từng hàm chính}

\subsubsection{Hàm \texttt{loadratings}}

\textit{Thiết kế:}
\begin{itemize}
    \item Đầu vào: tên bảng, đường dẫn file dữ liệu, kết nối CSDL.
    \item Đầu ra: bảng dữ liệu \texttt{ratings} đã được nạp đầy đủ.
    \item Hàm sử dụng lệnh \texttt{COPY} của PostgreSQL để nạp dữ liệu từ file vào bảng tạm, sau đó chuyển dữ liệu sang bảng chính. Việc dùng \texttt{COPY} giúp tốc độ nạp dữ liệu nhanh hơn rất nhiều so với việc đọc từng dòng và \texttt{INSERT} từng bản ghi, vì \texttt{COPY} tối ưu thao tác I/O và giảm số lần round-trip giữa Python và PostgreSQL.
    \item Sau khi nạp xong, bảng tạm được xóa để giải phóng bộ nhớ.
\end{itemize}
\textit{Phân tích hiệu năng:}  
Việc sử dụng \texttt{COPY} và thao tác bulk-insert giúp giảm thời gian xử lý đáng kể, đặc biệt với file dữ liệu lớn (hàng trăm nghìn dòng).

\subsubsection{Hàm \texttt{rangepartition}}

\textit{Thiết kế:}
\begin{itemize}
    \item Đầu vào: tên bảng gốc, số lượng phân mảnh, kết nối CSDL.
    \item Đầu ra: các bảng con \texttt{range\_part0}, \texttt{range\_part1}, ...
    \item Hàm tính toán khoảng giá trị rating cho từng partition, tạo bảng con tương ứng, sau đó dùng một câu lệnh \texttt{INSERT INTO ... SELECT ... WHERE ...} để chuyển dữ liệu vào từng bảng con.
    \item Đối với partition đầu tiên, điều kiện là \texttt{rating >= min\_range}, các partition sau là \texttt{rating > min\_range}. Điều này đảm bảo không bị trùng lặp hoặc bỏ sót giá trị biên.
\end{itemize}
\textit{Phân tích hiệu năng:}  
Việc dùng truy vấn SQL dạng \texttt{INSERT INTO ... SELECT ... WHERE ...} giúp PostgreSQL xử lý dữ liệu trực tiếp trên server, không cần chuyển dữ liệu về phía client, do đó tốc độ phân mảnh rất nhanh và tận dụng tối đa khả năng tối ưu hóa truy vấn của hệ quản trị CSDL.


\subsubsection{Hàm \texttt{roundrobinpartition}}

\textit{Thiết kế:}
\begin{itemize}
    \item Đầu vào: tên bảng gốc, số lượng phân mảnh, kết nối CSDL.
    \item Đầu ra: các bảng con \texttt{rrobin\_part0}, \texttt{rrobin\_part1}, ...
    \item Hàm sử dụng hàm cửa sổ \texttt{ROW\_NUMBER()} của SQL để đánh số thứ tự từng dòng, sau đó chia đều các dòng vào các bảng con dựa trên phép chia lấy dư (\texttt{rnum \% numberofpartitions}).
    \item Mỗi partition được tạo và nạp dữ liệu chỉ với một truy vấn SQL duy nhất.
\end{itemize}
\textit{Phân tích hiệu năng:}  
Việc tận dụng \texttt{ROW\_NUMBER()} và thực hiện phân phối dữ liệu hoàn toàn trên phía server giúp giảm thiểu thời gian xử lý, không cần lặp qua từng dòng ở phía Python, do đó tốc độ phân mảnh round-robin rất nhanh và ổn định, kể cả với dữ liệu lớn.

\subsubsection{Hàm \texttt{rangeinsert}}

\textit{Thiết kế:}
\begin{itemize}
    \item Đầu vào: tên bảng gốc, thông tin bản ghi mới (userid, itemid, rating), kết nối CSDL.
    \item Đầu ra: bản ghi mới được thêm vào bảng gốc và đúng bảng con range partition.
    \item Hàm xác định partition phù hợp dựa trên giá trị rating và số lượng partition hiện có (tính toán bằng công thức giống hàm \texttt{rangepartition}), sau đó chèn bản ghi vào cả bảng gốc và bảng con tương ứng.
\end{itemize}
\textit{Phân tích hiệu năng:}  
Việc xác định partition bằng phép toán số học và chỉ thực hiện hai lệnh \texttt{INSERT} giúp thao tác chèn rất nhanh, không cần quét lại toàn bộ bảng dữ liệu.

\subsubsection{Hàm \texttt{roundrobininsert}}

\textit{Thiết kế:}
\begin{itemize}
    \item Đầu vào: tên bảng gốc, thông tin bản ghi mới (userid, itemid, rating), kết nối CSDL.
    \item Đầu ra: bản ghi mới được thêm vào bảng gốc và đúng bảng con round-robin.
    \item Hàm xác định bảng con round-robin tiếp theo dựa trên tổng số bản ghi hiện có trong bảng gốc (dùng \texttt{COUNT(*)}), sau đó chèn bản ghi vào bảng con tương ứng theo quy tắc round-robin.
\end{itemize}
\textit{Phân tích hiệu năng:}  
Việc xác định bảng con chỉ cần một phép chia lấy dư, thao tác chèn chỉ thực hiện hai lệnh \texttt{INSERT}, do đó tốc độ xử lý rất nhanh và không bị ảnh hưởng bởi kích thước dữ liệu.
\newpage

\section{Cài đặt và kiểm thử chương trình}
\subsection{Cài đặt chương trình}
\subsubsection{Hàm \texttt{loadratings}}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{1.png}
    \caption{Hàm \texttt{loadratings}}

\end{figure}
Cụ thể chi tiết xử lý:
\begin{itemize}
    \item Kiểm tra xem bảng đã tồn tại chưa nếu có thì xóa
    \item Tạo bảng chính ratings với schema đúng
    \item Tạo bảng tạm ratings\_temp để parse dữ liệu theo định dạng đặc biệt với dấu ‘:’
    \item Dùng copy\_from để nạp dữ liệu nhanh từ dữ liệu sang bảng tạm
    \item Chuyển dữ liệu từ bảng tạm sang bảng chính trên những trường mà bảng chính cần
    \item Xóa bảng tạm
\end{itemize}

\subsubsection{Hàm \texttt{rangepartition}}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{2.png}
    \caption{Hàm \texttt{rangepartition}}
    
\end{figure}

Cụ thể chi tiết xử lý:
\begin{itemize}
    \item Xác định độ rộng mỗi khoảng: delta = 5 / N
    \item Với mỗi phân mảnh i, tạo bảng range\_part\{i\} và lấy dữ liệu từ bảng gốc:
    \begin{itemize}
        \item Nếu i = 0: lấy rating >= min AND <= max
        \item Nếu i > 0: lấy rating > min AND <= max
    \end{itemize}
\end{itemize}

\subsubsection{Hàm \texttt{roundrobinpartition}}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{3.png}
    \caption{Hàm \texttt{roundrobinpartition}}

\end{figure}

Cụ thể chi tiết xử lý:
\begin{itemize}
    \item Dùng hàm ROW\_NUMBER() để gán số thứ tự mỗi dòng
    \item Chia đều theo số phân mảnh bằng phép chia dư % N
    \item Mỗi bảng rrobin\_part\{i\} nhận các dòng row\_number % N == i
\end{itemize}

\subsubsection{Hàm \texttt{rangeinsert}}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{5.png}
    \caption{Hàm \texttt{rangeinsert}}

\end{figure}

Cụ thể chi tiết xử lý:
\begin{itemize}
    \item Tính index của phân mảnh bằng cách xác định đoạn [min, max] chứa rating
    \item Chèn bản ghi vào bảng gốc và bảng phân mảnh tương ứng
\end{itemize}

\subsubsection{Hàm \texttt{roundrobininsert}}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{4.png}
    \caption{Hàm \texttt{roundrobininsert}}

\end{figure}

Cụ thể chi tiết xử lý:
\begin{itemize}
    \item Lấy tổng số dòng trong bảng gốc -> total\_rows
    \item Tính index = (total\_rows – 1) % N
    \item Chèn vào bảng gốc và bảng rrobin\_part\{index\}
\end{itemize}

\subsection{Kiểm thử chương trình}
\subsubsection{Kiểm thử trên tập test\_data.dat}
\textbf{Đặc điểm của tập dữ liệu:} dữ liệu có định dạng như sau: UserID::MovieID::Rating::Timestamp và có 20 dòng
\begin{figure}[H]
    \centering
    \includegraphics[width=01\linewidth]{test_data.png}
    \caption{File test\_data.dat}

\end{figure}
\textbf{Cấu hình test case:}
\begin{itemize}
    \item Hàm \texttt{loadratings}: kiểm tra xem khi nạp vào có đủ 20 dòng không
    \item Hàm \texttt{rangepartition}: với đầu vào số phân mảnh là 5, kiểm tra sau khi thực hiện hàm thì có đủ 5 bảng thỏa mãn có dạng 'range\_part\%' không
    \item Hàm \texttt{roundrobinpartition}: với đầu vào số phân mảnh là 5, kiểm tra sau khi thực hiện hàm thì có đủ 5 bảng thỏa mãn có dạng 'rrobin\_part\%' không
    \item Hàm \texttt{rangeinsert}: với đầu vào là (userid, movieid, rating) = (100, 2, 3) thì nó có ở phân mảnh số 3 tức bảng range\_part2 không
    \item Hàm \texttt{roundrobininsert}: với đầu vào là (userid, movieid, rating) = (100, 1, 3) thì nó có ở phân mảnh số 1 tức bảng range\_part0 không
\end{itemize}
\textbf{Khi chạy chương trình ta thu được kết quả tất cả các test case đều pass như hình dưới:}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{test.png}
    \caption{Kiểm thử trên tập test\_data.dat bằng code nhóm thực hiện}

\end{figure}
\subsubsection{Kiểm thử trên tập ratings.dat}

\textbf{Đặc điểm của tập dữ liệu:} UserID::MovieID::Rating::Timestamp và có 10000054 dòng\\
\begin{figure}[H]
    \centering
    \includegraphics[width=01\linewidth]{data.png}
    \caption{File ratings.dat}

\end{figure}
\textbf{Cấu hình test case:}
\begin{itemize}
    \item Hàm \texttt{loadratings}: kiểm tra xem khi nạp vào có đủ 10000054 dòng không
    \item Hàm \texttt{rangepartition}: với đầu vào số phân mảnh là 5, kiểm tra sau khi thực hiện hàm thì có đủ 5 bảng thỏa mãn có dạng 'range\_part\%' không
    \item Hàm \texttt{roundrobinpartition}: với đầu vào số phân mảnh là 5, kiểm tra sau khi thực hiện hàm thì có đủ 5 bảng thỏa mãn có dạng 'rrobin\_part\%' không
    \item Hàm \texttt{rangeinsert}: với đầu vào là (userid, movieid, rating) = (100, 2, 3) thì nó có ở phân mảnh số 3 tức bảng range\_part2 không
    \item Hàm \texttt{roundrobininsert}: với đầu vào là (userid, movieid, rating) = (100, 1, 3) thì nó có ở phân mảnh số 5 tức bảng range\_part4 không
\end{itemize}
\textbf{Khi chạy chương trình ta thu được kết quả tất cả các test case đều pass như hình dưới:}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{real.png}
    \caption{Kiểm thử trên tập test\_data.dat bằng code nhóm thực hiện}
    

\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{realthay.png}
    \caption{Kiểm thử trên tập test\_data.dat bằng code mẫu của thầy đã thêm tính thời gian}
    

\end{figure}
\textbf{So sánh hiệu năng giữa code của nhóm và code mẫu của thầy dựa trên thời gian thực hiện(s)}
\begin{table}[H]
    \centering
    \small % Giảm cỡ chữ nếu cần để tránh tràn lề
    \renewcommand{\arraystretch}{1.5} % Tăng khoảng cách dòng
    \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|} % Sử dụng p{width} cho tất cả cột
        \hline
        \textbf{\makecell[c]{Hàm}} & 
        \textbf{\makecell[c]{Hiệu năng trên\\code của nhóm (s)}} & 
        \textbf{\makecell[c]{Hiệu năng trên\\code mẫu của thầy (s)}} \\
        \hline
        \texttt{loadratings lần 1} & 20.9004 & 27.8677 \\
        \hline
        \texttt{rangepartition} & 20.9893 & 20.4091 \\
        \hline
        \texttt{rangeinsert} & 0.008063 & 0.003 \\
        \hline
        \texttt{loadratings lần 2} & 22.8225 & 32.1877 \\
        \hline
        \texttt{roundrobinpartition} & 32.2945 & 33.5454 \\
        \hline
        \texttt{roundrobininsert} & 0.285790 & 0.242677 \\
        \hline
    \end{tabular}
    \caption{So sánh hiệu năng giữa code của nhóm và code mẫu của thầy}
\end{table}

Từ bảng so sánh hiệu năng giữa code của nhóm và code mẫu của thầy, có thể thấy rằng thời gian thực thi của hai giải pháp là khá tương đương ở hầu hết các hàm. Đặc biệt, ở các hàm xử lý dữ liệu lớn như \texttt{loadratings}, \texttt{rangepartition} và \texttt{roundrobinpartition}, code của nhóm có tốc độ xử lý nhanh hơn hoặc tương đương so với code mẫu. Điều này cho thấy nhóm đã tận dụng tốt các kỹ thuật tối ưu như sử dụng lệnh \texttt{COPY} để nạp dữ liệu hàng loạt và các truy vấn SQL tổng hợp để phân mảnh dữ liệu trực tiếp trên server, giảm thiểu thao tác lặp ở phía Python.\\

Ở các hàm chèn bản ghi đơn lẻ như \texttt{rangeinsert} và \texttt{roundrobininsert}, thời gian thực thi của code nhóm và code mẫu đều rất nhỏ, sự chênh lệch không đáng kể và chủ yếu phụ thuộc vào tốc độ truy vấn của hệ quản trị cơ sở dữ liệu tại thời điểm kiểm thử.\\

Nhìn chung, giải pháp của nhóm đảm bảo hiệu năng tốt, tận dụng tối đa sức mạnh của PostgreSQL, đồng thời vẫn đảm bảo tính đúng đắn và dễ mở rộng cho các bài toán lớn hơn trong thực tế.\\


\clearpage
\section{Kết luận và hướng phát triển}
\textbf{Ưu điểm:}
\begin{itemize}
    \item \textbf{Đáp ứng đầy đủ yêu cầu đề bài:}
    \begin{itemize}
        \item Tất cả các chức năng được đề cập trong yêu cầu kỹ thuật đã được triển khai thành công.
        \item Hệ thống đảm bảo thực hiện chính xác các kỹ thuật phân mảnh được mô tả (như Round Robin, Range...).
        \item Cấu trúc mã nguồn rõ ràng, dễ hiểu và có khả năng mở rộng hoặc chỉnh sửa khi cần thiết.
        \item Giao diện dòng lệnh hoặc giao diện web (nếu có) hỗ trợ thao tác dễ dàng, thân thiện với người dùng.
    \end{itemize}
    \item \textbf{Dữ liệu được xử lý chính xác, kiểm thử pass toàn bộ:}
    \begin{itemize}
        \item Tất cả các bài kiểm thử (test cases) – bao gồm chèn dữ liệu, phân mảnh, truy vấn, thống kê – đều cho kết quả đúng như mong đợi.
        \item Không có lỗi logic, không phát sinh ngoại lệ (exception) trong quá trình chạy thử.
        \item Các kết quả phân mảnh được kiểm chứng lại bằng truy vấn SQL và so sánh tay, đảm bảo tính toàn vẹn và hợp lý.
    \end{itemize}
    \item \textbf{Sử dụng PostgreSQL hiệu quả qua COPY và ROW\_NUMBER():}
    \begin{itemize}
        \item Lệnh COPY giúp tăng tốc độ nhập dữ liệu từ file CSV vào cơ sở dữ liệu PostgreSQL – nhanh gấp nhiều lần so với cách dùng INSERT từng dòng. Điều này giúp tiết kiệm thời gian khởi tạo dữ liệu ban đầu, đặc biệt với khối lượng lớn.
        \item Hàm ROW\_NUMBER() được sử dụng thông minh trong quá trình phân mảnh kiểu Round Robin:
        \begin{itemize}
            \item Cho phép đánh số thứ tự từng bản ghi một cách chính xác.
            \item Kết hợp với modulo (\%) để xác định vị trí phân mảnh cho từng dòng – hiệu quả, ngắn gọn, rõ ràng.
        \end{itemize}
    \end{itemize}
\end{itemize}

\textbf{Hạn chế:}
\begin{itemize}
    \item \textbf{Hiệu suất với dữ liệu lớn:}
    \begin{itemize}
        \item Tập dữ liệu MovieLens chứa 10 triệu đánh giá, rất lớn cho hệ thống.
        \item Những thuật toán phân mảnh đầu phải quét bảng nhiều lần, thời gian hoàn thành xử lý kéo dài.
    \end{itemize}
    \item \textbf{Xử lý chính xác các trường hợp biên:}
    \begin{itemize}
        \item Đảm bảo giá trị 0.0 và 5.0 được phân loại đúng vào các phân mảnh tương ứng.
        \item Tránh sai số trong quá trình tính toán các khoảng phân mảnh.
    \end{itemize}
    \item \textbf{Quản lý bộ nhớ và tài nguyên:}
    \begin{itemize}
        \item Dữ liệu có thể bị giữ quá lâu trong bộ nhớ dù không dùng đến.
        \item Có khả năng bộ nhớ bị tràn khi phải xử lý lượng lớn thông tin cùng một thời điểm.
    \end{itemize}
\end{itemize}

\textbf{Đề xuất phát triển:}
\begin{itemize}
    \item Thêm bảng metadata để quản lý trạng thái chèn round robin chính xác hơn và ghi lại:
    \begin{itemize}
        \item Partition hiện tại đang chờ chèn tiếp theo.
        \item Tổng số bản ghi ở mỗi partition (để giám sát cân bằng).
        \item Lịch sử phân phối (tùy chọn).
    \end{itemize}
    \item Giao diện web để xem nội dung phân mảnh:
    \begin{itemize}
        \item Xem danh sách các partition hiện có và bảng dữ liệu trong từng partition.
        \item Trình bày biểu đồ phân phối dữ liệu (dạng thanh, donut...).
        \item Thực hiện thao tác như: tạo partition mới, gán lại dữ liệu, xem thống kê chi tiết.
        \item Giao diện truy vấn thử dữ liệu từ các partition.
    \end{itemize}
    \item Hỗ trợ phân mảnh dọc và kết hợp:
    \begin{itemize}
        \item \textbf{Phân mảnh dọc:} Tách bảng theo cột, giúp mỗi site chỉ lưu những thuộc tính cần thiết, giảm kích thước bản ghi, tối ưu lưu trữ và truyền dữ liệu. Phù hợp khi các ứng dụng địa phương chỉ sử dụng một phần thông tin của bảng.
        \item \textbf{Phân mảnh kết hợp:} Kết hợp phân mảnh ngang và dọc. Ví dụ: trước tiên phân mảnh theo khoảng (range) rồi tách theo cột. Giải pháp hiệu quả cho hệ thống lớn, phức tạp và nhiều truy vấn đa chiều.
    \end{itemize}
\end{itemize}

\textbf{Bài học rút ra:}
\begin{itemize}
    \item Tạo bản thiết kế trước khi thực hiện các bước khác.
    \item Đảm bảo cơ sở dữ liệu không bị quá tải, tối ưu hóa thường xuyên.
    \item Kiểm thử thường xuyên và kỹ càng để tránh các lỗi.
\end{itemize}
\clearpage

\end{document}